# 性能

### 卡顿产生原因

* VSync(垂直同步信号)，系统图形服务会通过CADisplayLink等机制通知App。
* App主线程开始在CPU计算显示内容：**视图创建，布局计算，图片解码，文本绘制**等。
* CPU计算好后，提交到GPU，进行**变换，合成，渲染**。提交到帧缓冲区。
* 提交缓冲区后，切换双缓冲区，等待下一个VSync信号。
* 如果一个信号内，没有提交完成缓冲区，不进行切换，下一个信号仍然是上一帧的缓冲内容，导致掉帧。（双缓冲：前帧缓存，后帧缓存）

### CPU

加载资源，对象创建，对象调整，对象销毁，布局计算，Autolayout，文本计算，文本渲染，图片的解码， 图像的绘制（Core Graphics）都是在CPU上面进行的。

### GPU

GPU是一个专门为图形高并发计算而量身定做的处理单元，比CPU使用更少的电来完成工作并且GPU的浮点计算能力要超出CPU很多。

GPU的渲染性能要比CPU高效很多，同时对系统的负载和消耗也更低一些，所以在开发中，**我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理**，当涉及到光栅化等一些工作时，CPU也会参与进来，这点在后面再详细描述。

相对于CPU来说，GPU能干的事情比较单一：接收**提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合（合成）并渲染**，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。

### 优化方案

## **TableViewCell 复用**

在cellForRowAtIndexPath:回调的时候只创建实例，快速返回cell，不绑定数据。在willDisplayCell: forRowAtIndexPath:的时候绑定数据（赋值）。

## **高度缓存**

在tableView滑动时，会不断调用heightForRowAtIndexPath:，

当cell高度需要自适应时，每次回调都要计算高度，会导致 UI 卡顿。

为了避免重复无意义的计算，需要缓存高度。

也可以自定义的 model 中使用（且使用时，使用get方法处理）

## **不要动态创建视图**

- 在内存可控的前提下，缓存subview。
- 善用hidden。

## **减少视图层级**

- 减少subviews个数，用layer绘制元素。
- 少用clearColor，maskToBounds，阴影效果等。

## 避免动态添加图层

在cell中应该尽量避免动态创建图层。在初始化cell的时候一并将所有图层预先创建好，通过*hidden*属性控制子图层的显示或隐藏，因为单纯的显示操作要比创建快的多。

## **图片**

- 不要用JPEG的图片，应当使用PNG图片。
- 子线程预解码（Decode），主线程直接渲染。因为当image没有Decode，直接赋值给imageView会进行一个Decode操作。
- 优化图片大小，尽量不要动态缩放(contentMode)。
- 尽可能将多张图片合成为一张进行显示。
- 异步加载图片

## **减少透明 view**

使用透明view会引起blending，在iOS的图形处理中，blending主要指的是混合像素颜色的计算。最直观的例子就是，我们把两个图层叠加在一起，如果第一个图层的透明的，则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。

会导致blending的原因：

- UIView的alpha<1。
- UIImageView的image含有alpha channel（即使UIImageView的alpha是1，但只要image含有透明通道，则仍会导致blending）。

为什么blending会导致性能的损失？

原因是很直观的，如果一个图层是不透明的，则系统直接显示该图层的颜色即可。而如果图层是透明的，则会引起更多的计算，因为需要把另一个的图层也包括进来，进行混合后的颜色计算。

- opaque设置为YES，减少性能消耗，因为GPU将不会做任何合成，而是简单从这个层拷贝。

## **减少离屏渲染**

离屏渲染指的是在图像在绘制到当前屏幕前，需要先进行一次渲染，之后才绘制到当前屏幕。

置了以下属性时，都会触发离屏渲染：

- layer.shouldRasterize，光栅化
- layer.mask，遮罩
- layer.allowsGroupOpacity为YES，layer.opacity的值小于1.0
- layer.cornerRadius，并且设置layer.masksToBounds为YES。可以使用剪切过的图片，或者使用layer画来解决。
- layer.shadows，(表示相关的shadow开头的属性)，使用shadowPath代替。

## **异步渲染**

在子线程绘制，主线程渲染

解决因图层层级多造成的性能问题，我们可以通过重写*drawReact:*方法，调用*Core Graphics*框架中的API进行异步绘制，提高效率。*drawRect:*本身是异步的。另外*drawRect:*中大量的绘制操作也会造成内存的增长，可以使用*CAShapeLayer*来代替

## **按需加载**

- 局部刷新，刷新一个cell就能解决的，坚决不刷新整个section或者整个tableView，刷新最小单元元素。
- 利用runloop提高滑动流畅性，在滑动停止的时候再加载内容，像那种一闪而过的（快速滑动），就没有必要加载，可以使用默认的占位符填充内容。

## **关于性能测试**

首先，我们要有一个定位问题的模式。我们可以按照这样的顺序来逐步定位，发现问题。

1. 定位帧率，为了给用户流畅的感受，我们需要保持帧率在60帧左右。当遇到问题后，我们首先检查一下帧率是否保持在60帧。
2. 定位瓶颈，究竟是CPU还是GPU。我们希望占用率越少越好，一是为了流畅性，二也节省了电力。
3. 检查有没有做无必要的CPU渲染，例如有些地方我们重写了drawRect:，而其实是我们不需要也不应该的。我们希望GPU负责更多的工作。
4. 检查有没有过多的离屏渲染，这会耗费GPU的资源，像前面已经分析的到的。离屏渲染会导致GPU需要不断地onScreen和offscreen进行上下文切换。我们希望有更少的离屏渲染。
5. 检查我们有无过多的Blending，GPU渲染一AC个不透明的图层更省资源。
6. 检查图片的格式是否为常用格式，大小是否正常。如果一个图片格式不被GPU所支持，则只能通过CPU来渲染。一般我们在iOS开发中都应该用PNG格式，之前阅读过的一些资料也有指出苹果特意为PNG格式做了渲染和压缩算法上的优化。
7. 检查是否有耗费资源多的View或效果，我们需要合理有节制的使用。
8. 最后，我们需要检查在我们View层级中是否有不正确的地方。例如有时我们不断的添加或移除View，有时就会在不经意间导致bug的发生。

## **测试工具：**

- Core Animation，Instruments里的图形性能问题的测试工具。
- view debugging，Xcode 自带的，视图层级。
- reveal，视图层级。
